{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Map with statistics","text":"<p>The package allows to display an interactive map with a choropleth displaying some statistics as color per hectare (100x100 meter square).</p> <p></p> <p>What is the use-case?</p> <p>The typical use-case would be to visualise and do plausibility checks of hectare-level data   as well as to compare statistics between geographic areas.</p> <p>The package is created and tested to work for the Switzerland coordinates, however, one could try to use it for any other map with hectare statistics.</p> <p>Read about usage in Quick start guide</p>"},{"location":"api/","title":"API","text":""},{"location":"api/#src.map_with_stats.map.build_map","title":"<code>build_map(gdf_stats, title, bins_type, n_bins=5, clip_quantile=0.01, map_tiles_provider='OpenStreetMap', optimise_choropleth_size=True, coordinates_start=(47.39, 8.53), zoom_start=15, max_n_hectares_to_display=None, plot_boundaries=False, fill_opacity=0.6)</code>","text":"<p>Generate a folium map with the some statistics per hectare added as a choropleth alayer on top.</p> <p>See FAQ for detailed explanation and typical use-cases of more complex attributes.</p> <p>Parameters:</p> Name Type Description Default <code>gdf_stats</code> <code>GeoDataFrame</code> <p>input table with the hectare polygons and statistics values.</p> required <code>title</code> <code>str</code> <p>the name to be displayed as the color-map title as well as the entry in the control panel.</p> required <code>bins_type</code> <code>str</code> <p>The type of binning for the choropleth. Accepted values are \"equidistant\" and \"quantiles\" that would define bins either on the linear or on the quantile scale.</p> required <code>n_bins</code> <code>int</code> <p>number of bins to use. Defaults to 5.</p> <code>5</code> <code>clip_quantile</code> <code>Optional[float]</code> <p>clip/winzorise statistics values to specific quntiles. The effect is double-sided. Set to None to avoid any clipping. Defaults to 0.01.</p> <code>0.01</code> <code>map_tiles_provider</code> <code>str</code> <p>Map tileset to use. The value is passed over to folium.Map. Defaults to \"OpenStreetMap\".</p> <code>'OpenStreetMap'</code> <code>optimise_choropleth_size</code> <code>bool</code> <p>Set to True to reduce precision of polygon coordinates to a pre-defined optimised value that will keep hectare boundary precision. This allows to reduce the size of the map HTML dump on disk. Defaults to True.</p> <code>True</code> <code>coordinates_start</code> <code>Tuple[float, float]</code> <p>starting coordinated in longiotude and latitude. Defaults to (47.39, 8.53) [Z\u00fcrich].</p> <code>(47.39, 8.53)</code> <code>zoom_start</code> <code>int</code> <p>starting zoom. Defaults to 15.</p> <code>15</code> <code>max_n_hectares_to_display</code> <code>Optional[int]</code> <p>the top-N hectares to display. Defaults to None.</p> <code>None</code> <code>plot_boundaries</code> <code>bool</code> <p>set to True to display boundaries between choroplet elements. This is useful if you visualise not hectares but some administrative entities. Defaults to False.</p> <code>False</code> <code>fill_opacity</code> <code>float</code> <p>opacity of the choropleth. Defaults to 0.6.</p> <code>0.6</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>unsupported <code>bins_type</code> provided.</p> <p>Returns:</p> Type Description <code>Map</code> <p>folium.Map: the map with cholopleth layer</p> Source code in <code>src/map_with_stats/map.py</code> <pre><code>def build_map(\n    gdf_stats: gpd.GeoDataFrame,\n    title: str,\n    bins_type: str,\n    n_bins: int = 5,\n    clip_quantile: Optional[float] = 0.01,\n    map_tiles_provider: str = \"OpenStreetMap\",\n    optimise_choropleth_size: bool = True,\n    coordinates_start: Tuple[float, float] = (47.39, 8.53),\n    zoom_start: int = 15,\n    max_n_hectares_to_display: Optional[int] = None,\n    plot_boundaries: bool = False,\n    fill_opacity: float = 0.6,\n) -&gt; folium.Map:\n    \"\"\"Generate a folium map with the some statistics per hectare added as a choropleth alayer on top.\n\n    See [FAQ](faq) for detailed explanation and typical use-cases of more complex attributes.\n\n    Args:\n        gdf_stats (gpd.GeoDataFrame): input table with the hectare polygons and statistics values.\n        title (str): the name to be displayed as the color-map title as well as\n            the entry in the control panel.\n        bins_type (str): The type of binning for the choropleth.\n            Accepted values are _\"equidistant\"_ and _\"quantiles\"_\n            that would define bins either on the linear or on the quantile scale.\n        n_bins (int, optional): number of bins to use. Defaults to 5.\n        clip_quantile (Optional[float], optional): clip/winzorise statistics values to specific quntiles.\n            The effect is double-sided.\n            Set to _None_ to avoid any clipping.\n            Defaults to 0.01.\n        map_tiles_provider (str, optional): Map tileset to use.\n            The value is passed over to [folium.Map](https://python-visualization.github.io/folium/modules.html#folium.folium.Map).\n            Defaults to \"OpenStreetMap\".\n        optimise_choropleth_size (bool, optional): Set to True to reduce precision of polygon\n            coordinates to a pre-defined optimised value that will keep hectare boundary precision.\n            This allows to reduce the size of the map HTML dump on disk. Defaults to True.\n        coordinates_start (Tuple[float, float], optional): starting coordinated in longiotude and latitude.\n            Defaults to (47.39, 8.53) [Z\u00fcrich].\n        zoom_start (int, optional): starting zoom. Defaults to 15.\n        max_n_hectares_to_display (Optional[int], optional): the top-N hectares to display.\n            Defaults to None.\n        plot_boundaries (bool, optional): set to True to display boundaries between choroplet elements.\n            This is useful if you visualise not hectares but some administrative entities.\n            Defaults to False.\n        fill_opacity (float, optional): opacity of the choropleth. Defaults to 0.6.\n\n    Raises:\n        ValueError: unsupported `bins_type` provided.\n\n    Returns:\n        folium.Map: the map with cholopleth layer\n    \"\"\"\n    _check_cols_in_df(gdf_stats, [\"geometry\", \"value\"])\n\n    # make a copy to avoid modifying input data in-place\n    gdf = gdf_stats.copy(deep=True)\n\n    ch_map = folium.Map(\n        location=coordinates_start, zoom_start=zoom_start, tiles=map_tiles_provider\n    )\n\n    # optimise the number of hectares to be displayed as choropleth\n    # display becomes very slow and sometimes stops work for a very large number fo elements\n    if max_n_hectares_to_display:\n        cumsum = gdf_stats[\"value\"].value_counts().sort_index(ascending=False).cumsum()\n        min_value = cumsum[cumsum &lt;= max_n_hectares_to_display].index[-1]\n        gdf = gdf[gdf[\"value\"] &gt;= min_value]\n    # coordinates of the vetrices of hectares are stores with double precision,\n    # that is more  than neccessary and will lead to wasted space, when stored in html\n    # the number of digits after comma has been optimised to lead differences less than 1m in LV03 CRS\n    if optimise_choropleth_size:\n        gdf[\"geometry\"] = gdf[\"geometry\"].apply(\n            _round_coordinates, n_digits_after_comma=6\n        )\n    # get values to be used for colors in the choropleth\n    cliped_values = gdf[\"value\"]\n    if clip_quantile is not None:\n        clip_min, clip_max = cliped_values.quantile((clip_quantile, 1 - clip_quantile))\n        cliped_values = cliped_values.clip(clip_min, clip_max)\n    # get either number of equidistant bins or bins defined by quantiles\n    bins: Union[int, List[float]]\n    if bins_type == \"quantiles\":\n        quantiles = [i / (n_bins) for i in range(n_bins + 1)]\n        bins = list(cliped_values.quantile(quantiles))\n    elif bins_type == \"equidistant\":\n        bins = n_bins\n    else:\n        raise ValueError(f\"Unexpected type of bins: {bins_type}\")\n\n    if plot_boundaries:\n        # thin gray line\n        line_weight = 0.5\n        line_color = \"gray\"\n    else:\n        # no line, for example around hectares\n        line_weight = 0\n        line_color = \"black\"\n    # coloured choropleth with the colour reflecting the statistics value\n    # for example squares in the case of hectares\n    choropleth = folium.Choropleth(\n        geo_data=gdf,\n        data=cliped_values,\n        key_on=\"feature.id\",  # index of the geodataframe is transformed into `id` field\n        fill_color=\"YlOrBr\",\n        fill_opacity=fill_opacity,\n        bins=bins,\n        line_weight=line_weight,\n        line_color=line_color,\n        nan_fill_opacity=1,  # fully transparent hectares if the valueis mising\n        legend_name=title,  # title under the color scale\n        name=title,  # name of thew layer, e.g. in the layer control\n    ).add_to(ch_map)\n\n    # optional X and Y coordinates that would appear for hectares, but not for administrative regions\n    cols_xy = [c for c in [\"X\", \"Y\"] if c in gdf]\n    labels_xy = [\"LV03 X:\", \"LV03 Y:\"] if cols_xy else []\n    # add tooltip to appear, when pointing at a hectar\n    tooltip = folium.GeoJsonTooltip(\n        # column names with values to be displayed\n        fields=cols_xy + [\"value\"],\n        # text to be shown explaining each value\n        aliases=labels_xy + [f\"{title}:\"],\n        localize=True,\n        max_width=800,\n    )\n    tooltip.add_to(choropleth.geojson)\n\n    folium.LayerControl().add_to(ch_map)\n    return ch_map\n</code></pre>"},{"location":"api/#src.map_with_stats.data.create_geo_df_with_hectar_polygons","title":"<code>create_geo_df_with_hectar_polygons(df, col_value, crs_out='EPSG:4326', crs_in='EPSG:21781', grid_size=100)</code>","text":"<p>Generate hectare polygons.</p> <p>Given a pandas dataframe with \"X\", \"Y\" coordinates of the bottom-left (south-west) corner of the hectares and a column <code>col_value</code> with values, create a geopandas geodataframe with hectare polygons and the selected column with values.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>input data. The code expects to find the following columns: \"X\", \"Y\", <code>col_value</code>.</p> required <code>col_value</code> <code>str</code> <p>column name with some values</p> required <code>crs_out</code> <code>str</code> <p>coordinate system to which output polygons are transformed. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>crs_in</code> <code>str</code> <p>coordinate system of the input data. Defaults to \"EPSG:21781\" (=LV03).</p> <code>'EPSG:21781'</code> <code>grid_size</code> <code>int</code> <p>grid size in meters. Defaults to 100 ()i.e. hectar.</p> <code>100</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>gpd.GeoDataFrame: a table with hectare polygons and the values.</p> Source code in <code>src/map_with_stats/data.py</code> <pre><code>def create_geo_df_with_hectar_polygons(\n    df: pd.DataFrame,\n    col_value: str,\n    crs_out: str = \"EPSG:4326\",\n    crs_in: str = \"EPSG:21781\",\n    grid_size: int = 100,\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"Generate hectare polygons.\n\n    Given a pandas dataframe with _\"X\", \"Y\"_ coordinates of the bottom-left (south-west) corner\n    of the hectares and a column `col_value` with values, create a geopandas geodataframe with\n    hectare polygons and the selected column with values.\n\n    Args:\n        df (pd.DataFrame): input data. The code expects to find the following columns: _\"X\", \"Y\", `col_value`_.\n        col_value (str): column name with some values\n        crs_out (str, optional): coordinate system to which output polygons are transformed.\n            Defaults to \"EPSG:4326\".\n        crs_in (str, optional): coordinate system of the input data. Defaults to \"EPSG:21781\" (=LV03).\n        grid_size (int, optional): grid size in meters. Defaults to 100 ()i.e. hectar.\n\n    Returns:\n        gpd.GeoDataFrame: a table with hectare polygons and the values.\n    \"\"\"\n    _check_cols_in_df(df, [\"X\", \"Y\", col_value])\n    polygons = []\n    for row in df.itertuples():\n        x, y = row.X, row.Y\n        polygons.append(\n            shapely.Polygon(\n                [\n                    (x, y),\n                    (x + grid_size, y),\n                    (x + grid_size, y + grid_size),\n                    (x, y + grid_size),\n                ]\n            )\n        )\n    gdf_stats = gpd.GeoDataFrame(\n        {\n            \"geometry\": polygons,\n            \"value\": df[col_value],\n            \"hectare_id\": df[\"X\"] // grid_size * 10_000 + df[\"Y\"] // grid_size,\n            \"X\": df[\"X\"],\n            \"Y\": df[\"Y\"],\n        },\n        index=df.index,\n        crs=crs_in,\n    )\n    # transform into the desired coordinate system\n    gdf_stats = gdf_stats.to_crs(crs_out)\n    return gdf_stats\n</code></pre>"},{"location":"api/#src.map_with_stats.data.filter_xy","title":"<code>filter_xy(df, ch_x_min, ch_y_min, ch_x_max, ch_y_max)</code>","text":"<p>Filter input data to be within range of X and Y coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>inout data. The code expects to find the following columns: \"X\", \"Y\".</p> required <code>ch_x_min</code> <code>float</code> <p>minimum value of X</p> required <code>ch_y_min</code> <code>float</code> <p>minimum value of Y</p> required <code>ch_x_max</code> <code>float</code> <p>maximum value of X</p> required <code>ch_y_max</code> <code>float</code> <p>maximum value of Y</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: input data with the restricted \"X\", \"Y\" values</p> Source code in <code>src/map_with_stats/data.py</code> <pre><code>def filter_xy(\n    df: pd.DataFrame, ch_x_min: float, ch_y_min: float, ch_x_max: float, ch_y_max: float\n) -&gt; pd.DataFrame:\n    \"\"\"Filter input data to be within range of X and Y coordinates.\n\n    Args:\n        df (pd.DataFrame): inout data. The code expects to find the following columns: _\"X\", \"Y\"_.\n        ch_x_min (float): minimum value of X\n        ch_y_min (float): minimum value of Y\n        ch_x_max (float): maximum value of X\n        ch_y_max (float): maximum value of Y\n\n    Returns:\n        pd.DataFrame: input data with the restricted _\"X\", \"Y\"_ values\n    \"\"\"\n    _check_cols_in_df(df, [\"X\", \"Y\"])\n    mask_x = df[\"X\"].between(ch_x_min, ch_x_max)\n    mask_y = df[\"Y\"].between(ch_y_min, ch_y_max)\n    mask_in_range = mask_x &amp; mask_y\n    return df[mask_in_range]\n</code></pre>"},{"location":"api/#src.map_with_stats.utils.hectare2xy","title":"<code>hectare2xy(df, col_hectare='hectare_id')</code>","text":"<p>Convert hectare ID into (x,y) coorsinates in the LV03 coordinate system.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>input table.</p> required <code>col_hectare</code> <code>str</code> <p>name of the column with hectare IDs. The common convention is that coordinates x=ABCDEF, y=ZYXWVT are represented by a hectare ID ABCDZYXW. Defaults to \"hectare_id\".</p> <code>'hectare_id'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: input table with \"X\", \"Y\" columns added (or overwritten, if they existed in the input)</p> Source code in <code>src/map_with_stats/utils.py</code> <pre><code>def hectare2xy(df: pd.DataFrame, col_hectare: str = \"hectare_id\") -&gt; pd.DataFrame:\n    \"\"\"Convert hectare ID into (x,y) coorsinates in the LV03 coordinate system.\n\n    Args:\n        df (pd.DataFrame): input table.\n        col_hectare (str, optional): name of the column with hectare IDs.\n            The common convention is that coordinates _x=ABCDEF_, _y=ZYXWVT_\n            are represented by a hectare ID _ABCDZYXW_.\n            Defaults to \"hectare_id\".\n\n    Returns:\n        pd.DataFrame: input table with _\"X\", \"Y\"_ columns added (or overwritten,\n            if they existed in the input)\n    \"\"\"\n    _check_cols_in_df(df, [col_hectare])\n    df_out = df.copy(deep=True)\n    df_out[\"X\"] = df_out[col_hectare] // 10_000 * 100\n    df_out[\"Y\"] = df_out[col_hectare] % 10_000 * 100\n    return df_out\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#why-does-one-need-to-restrict-the-data","title":"Why does one need to restrict the data?","text":"<p>Question</p> <p>The example in the quick start quide used a subset of data for visualisation. What is the reason and what shall I know about it?</p> <p>The reason is that <code>folium</code> + <code>leaflet</code> do not seem to handle well large choropleth displayed. On my laptop I managed to visualise 100k-200k hectares in a choropleth and afterwards the map didn't open.</p> <p>The way to work around this limitations could be:</p> <ul> <li>restrict displayed statistics to some area, for example around the starting point,   like it has been done in the example</li> <li>do not constrain geographic location but restrict the choropleth to include only the top-N   hectares. This can be achieved by providing <code>max_n_hectares_to_display</code> argument to <code>mws.build_map()</code>.   This will identify an additional constraint statistic value &gt; X and use it to display   only hectares with \"large\" statistics values.</li> </ul>"},{"location":"faq/#how-to-change-the-starting-location-and-the-zoom","title":"How to change the starting location and the zoom?","text":"<p>Question</p> <p>By default the map will be showing Z\u00fcrich city. How could I change it?</p> <p>The starting coordinates are passed as <code>coordinates_start</code> argument and the zoom as <code>zoom_start</code>.</p>"},{"location":"faq/#how-to-reduce-the-size-of-the-html-file","title":"How to reduce the size of the HTML file?","text":"<p>Question</p> <p>The output HTML file could be large. Is there a way to reduce it?</p> <p>Yes, one could use <code>optimise_choropleth_size</code> argument. This will reduce precision of the longitude and latitude coordinates that are dumped as floats with multiple digits after the comma into the HTML. The rounding precision has been optimised to lead less than 1 meter bias in the LV03 coordinate system.</p>"},{"location":"faq/#how-to-optimise-the-color-bar","title":"How to optimise the color bar","text":"<p>Question</p> <p>The resulting color bar is too squeezed and does not deliver insights into differences between hectares. What can I do about it?</p> <p>Typically this would happen for a very non-uniform distribution in the data, in particular in the presence of outliers. One could play with he following arguments:</p> <ul> <li><code>bins_type</code>: choose between \"equidistant\" and \"quantiles\" that would define bins   either on the linear or on the quantile scale.</li> <li><code>clip_quantile</code>: this will define the quantile on both sides of the distribution to be   clipped/winsorised. This would eliminate any outliers in long tails.</li> </ul> <p>Question</p> <p>I have categorical data and the number of categories is higher than the number of colors. What can I do about it?</p> <p>Use <code>n_bins</code> to define as many bins as there are categories. <code>bins_type=\"equidistant\"</code> would be optimal in this case.</p>"},{"location":"quick_start/","title":"Quick start guide","text":""},{"location":"quick_start/#installation","title":"Installation","text":"<pre><code>pip install map_with_stats\n</code></pre>"},{"location":"quick_start/#usage-example","title":"Usage example","text":"<p>For visualisation you will need some statistics per hectare. Individual hectares are defined by the X,Y coordinates in the LV03 coordinate system of the bottom-left (=south-west) corner.</p> <ol> <li>Such data could be for example downloaded from    the BFS website.</li> <li>For example, one can get population data per hectare for year 2021 from      here.</li> <li>Download and extract STATPOP2021.csv from the archive.</li> <li>Generate the HTML with the map:    <pre><code>import pandas as pd\n\nimport map_with_stats as mws\n\n\ndata_raw = pd.read_csv(\"STATPOP2021.csv\", sep=\";\")\ndata = data_raw[[\"RELI\", \"B21BTOT\"]]\ndata = mws.hectare2xy(data, \"RELI\")  # (1)!\ngdf_stats = mws.create_geo_df_with_hectar_polygons(data, \"B21BTOT\", crs_out=\"EPSG:4326\")  # (2)!\n\n# restrict data to the Z\u00fcrich neighbourhood\nmask_x = data[\"X\"].between(6700_00, 7000_00)\nmask_y = data[\"Y\"].between(2330_00, 2630_00)\ngdf = gdf_stats[mask_x &amp; mask_y]  # (3)!\n\n# `build_map` is the main helper function that will create a map with a coropleth layer\ntitle = \"Dummy data\"  # (4)!\nmap = mws.build_map(gdf, title , \"equidistant\")\nmap.save(\"map.html\")\n</code></pre><ol> <li><code>hectare2xy</code> is a helper function that extracts X,Y coordinates from the hectare ID</li> <li><code>create_geo_df_with_hectar_polygons</code> is a helper function that creates GeoDataFrame with a polygon for each hectare</li> <li>This step is optional- read FAQ for more details</li> <li>Title will be used as data description in the tooltip and colormap</li> </ol> </li> </ol>"}]}